'''
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。
你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。
本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。
输入格式
两个正整数，表示每种包装中糖的颗数(都不多于1000)

输出格式
一个正整数，表示最大不能买到的糖数

样例输入1
4 7
样例输出1
17
样例输入2
3 5
样例输出2
7
'''
#ax+by<=a*b
'''
我们知道 a , b a,b a,b两个数是质数，最大公约数是1，那么他们之间由 a x + b y = z ax+by=z ax+by=z得到的最大的 z z 
z值肯定是 a ∗ b a*b a∗b，因为超过 a ∗ b a*b a∗b，肯定能组合得到（最大公约数是1），所以我们直接建立一个列表，
列表里面存放 a x + b y = z ax+by=z ax+by=z的 z z z值，x in range(b + 1)，y in range(a + 1)，
然后把这个列表从大到小排序，相邻数字间隔超过1的必然是中间值取不到，输出即可：
'''
a,b=map(int,input().split())
list_z=[]
for x in range(b+1):
    for y in range(a+1):#求出a*b以下的所有a b能组合成的数，然后进行递减排序，间隔大于1的数之前的数必然取不到，取最大的取不到的数
        z=a*x+b*y
        if z<=a*b:
            list_z.append(z)
list_z.sort(reverse=True)#True是递减排序
#print(list_z)
for i in range(len(list_z)-1):
    if list_z[i]-list_z[i+1]>1:
        max_not=list_z[i]-1
        break
print(max_not)